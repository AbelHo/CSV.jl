<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CSV.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CSV.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/CSV.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="CSV.jl-Documentation-1" href="#CSV.jl-Documentation-1">CSV.jl Documentation</a></h1><p>CSV.jl is built to be a fast and flexible pure-Julia library for handling delimited text files.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSV.File" href="#CSV.File"><code>CSV.File</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CSV.File(source; kwargs...) =&gt; CSV.File</code></pre><p>Read a csv input (a filename given as a String or FilePaths.jl type, or any other IO source), returning a <code>CSV.File</code> object. Opens the file and uses passed arguments to detect the number of columns and column types. The returned <code>CSV.File</code> object supports the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface and can iterate <code>CSV.Row</code>s. <code>CSV.Row</code> supports <code>propertynames</code> and <code>getproperty</code> to access individual row values. Note that duplicate column names will be detected and adjusted to ensure uniqueness (duplicate column name <code>a</code> will become <code>a_1</code>). For example, one could iterate over a csv file with column names <code>a</code>, <code>b</code>, and <code>c</code> by doing:</p><pre><code class="language-julia">for row in CSV.File(file)
    println(&quot;a=$(row.a), b=$(row.b), c=$(row.c)&quot;)
end</code></pre><p>By supporting the Tables.jl interface, a <code>CSV.File</code> can also be a table input to any other table sink function. Like:</p><pre><code class="language-julia"># materialize a csv file as a DataFrame
df = CSV.File(file) |&gt; DataFrame!

# load a csv file directly into an sqlite database table
db = SQLite.DB()
tbl = CSV.File(file) |&gt; SQLite.load!(db, &quot;sqlite_table&quot;)</code></pre><p>Supported keyword arguments include:</p><ul><li>File layout options:<ul><li><code>header=1</code>: the <code>header</code> argument can be an <code>Int</code>, indicating the row to parse for column names; or a <code>Range</code>, indicating a span of rows to be concatenated together as column names; or an entire <code>Vector{Symbol}</code> or <code>Vector{String}</code> to use as column names; if a file doesn&#39;t have column names, either provide them as a <code>Vector</code>, or set <code>header=0</code> or <code>header=false</code> and column names will be auto-generated (<code>Column1</code>, <code>Column2</code>, etc.)</li><li><code>normalizenames=false</code>: whether column names should be &quot;normalized&quot; into valid Julia identifier symbols; useful when iterating rows and accessing column values of a row via <code>getproperty</code> (e.g. <code>row.col1</code>)</li><li><code>datarow</code>: an <code>Int</code> argument to specify the row where the data starts in the csv file; by default, the next row after the <code>header</code> row is used. If <code>header=0</code>, then the 1st row is assumed to be the start of data</li><li><code>skipto::Int</code>: similar to <code>datarow</code>, specifies the number of rows to skip before starting to read data</li><li><code>footerskip::Int</code>: number of rows at the end of a file to skip parsing</li><li><code>limit</code>: an <code>Int</code> to indicate a limited number of rows to parse in a csv file; use in combination with <code>skipto</code> to read a specific, contiguous chunk within a file</li><li><code>transpose::Bool</code>: read a csv file &quot;transposed&quot;, i.e. each column is parsed as a row</li><li><code>comment</code>: rows that begin with this <code>String</code> will be skipped while parsing</li><li><code>use_mmap::Bool=!Sys.iswindows()</code>: whether the file should be mmapped for reading, which in some cases can be faster</li></ul></li><li>Parsing options:<ul><li><code>missingstrings</code>, <code>missingstring</code>: either a <code>String</code>, or <code>Vector{String}</code> to use as sentinel values that will be parsed as <code>missing</code>; by default, only an empty field (two consecutive delimiters) is considered <code>missing</code></li><li><code>delim=&#39;,&#39;</code>: a <code>Char</code> or <code>String</code> that indicates how columns are delimited in a file; if no argument is provided, parsing will try to detect the most consistent delimiter on the first 10 rows of the file</li><li><code>ignorerepeated::Bool=false</code>: whether repeated (consecutive) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells</li><li><code>quotechar=&#39;&quot;&#39;</code>, <code>openquotechar</code>, <code>closequotechar</code>: a <code>Char</code> (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters</li><li><code>escapechar=&#39;&quot;&#39;</code>: the <code>Char</code> used to escape quote characters in a quoted field</li><li><code>dateformat::Union{String, Dates.DateFormat, Nothing}</code>: a date format string to indicate how Date/DateTime columns are formatted for the entire file</li><li><code>decimal=&#39;.&#39;</code>: a <code>Char</code> indicating how decimals are separated in floats, i.e. <code>3.14</code> used &#39;.&#39;, or <code>3,14</code> uses a comma &#39;,&#39;</li><li><code>truestrings</code>, <code>falsestrings</code>: <code>Vectors of Strings</code> that indicate how <code>true</code> or <code>false</code> values are represented; by default only <code>true</code> and <code>false</code> are treated as <code>Bool</code></li></ul></li><li>Column Type Options:<ul><li><code>type</code>: a single type to use for parsing an entire file; i.e. all columns will be treated as the same type; useful for matrix-like data files</li><li><code>types</code>: a Vector or Dict of types to be used for column types; a Dict can map column index <code>Int</code>, or name <code>Symbol</code> or <code>String</code> to type for a column, i.e. Dict(1=&gt;Float64) will set the first column as a Float64, Dict(:column1=&gt;Float64) will set the column named column1 to Float64 and, Dict(&quot;column1&quot;=&gt;Float64) will set the column1 to Float64; if a <code>Vector</code> if provided, it must match the # of columns provided or detected in <code>header</code></li><li><code>typemap::Dict{Type, Type}</code>: a mapping of a type that should be replaced in every instance with another type, i.e. <code>Dict(Float64=&gt;String)</code> would change every detected <code>Float64</code> column to be parsed as <code>String</code></li><li><code>pool::Union{Bool, Float64}=0.1</code>: if <code>true</code>, <em>all</em> columns detected as <code>String</code> will be internally pooled; alternatively, the proportion of unique values below which <code>String</code> columns should be pooled (by default 0.1, meaning that if the # of unique strings in a column is under 10%, it will be pooled)</li><li><code>strict::Bool=false</code>: whether invalid values should throw a parsing error or be replaced with <code>missing</code></li><li><code>silencewarnings::Bool=false</code>: if <code>strict=false</code>, whether invalid value warnings should be silenced</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/a7569c0d8cf26a90cb89dbdfe32e2911979577ed/src/CSV.jl#L55-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSV.read" href="#CSV.read"><code>CSV.read</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>CSV.read(source; kwargs...)</code> =&gt; <code>DataFrame</code></p><p>Parses a delimited file into a <code>DataFrame</code>.</p><p>Positional arguments:</p><ul><li><code>source</code>: can be a file name (String or FilePaths.jl type) of the location of the csv file or an <code>IO</code> or <code>Vector{UInt8}</code> buffer to read the csv from directly</li></ul><p>Supported keyword arguments include:</p><ul><li>File layout options:<ul><li><code>header=1</code>: the <code>header</code> argument can be an <code>Int</code>, indicating the row to parse for column names; or a <code>Range</code>, indicating a span of rows to be concatenated together as column names; or an entire <code>Vector{Symbol}</code> or <code>Vector{String}</code> to use as column names; if a file doesn&#39;t have column names, either provide them as a <code>Vector</code>, or set <code>header=0</code> or <code>header=false</code> and column names will be auto-generated (<code>Column1</code>, <code>Column2</code>, etc.)</li><li><code>normalizenames=false</code>: whether column names should be &quot;normalized&quot; into valid Julia identifier symbols; useful when iterating rows and accessing column values of a row via <code>getproperty</code> (e.g. <code>row.col1</code>)</li><li><code>datarow</code>: an <code>Int</code> argument to specify the row where the data starts in the csv file; by default, the next row after the <code>header</code> row is used. If <code>header=0</code>, then the 1st row is assumed to be the start of data</li><li><code>skipto::Int</code>: similar to <code>datarow</code>, specifies the number of rows to skip before starting to read data</li><li><code>footerskip::Int</code>: number of rows at the end of a file to skip parsing</li><li><code>limit</code>: an <code>Int</code> to indicate a limited number of rows to parse in a csv file; use in combination with <code>skipto</code> to read a specific, contiguous chunk within a file</li><li><code>transpose::Bool</code>: read a csv file &quot;transposed&quot;, i.e. each column is parsed as a row</li><li><code>comment</code>: rows that begin with this <code>String</code> will be skipped while parsing</li><li><code>use_mmap::Bool=!Sys.iswindows()</code>: whether the file should be mmapped for reading, which in some cases can be faster</li></ul></li><li>Parsing options:<ul><li><code>missingstrings</code>, <code>missingstring</code>: either a <code>String</code>, or <code>Vector{String}</code> to use as sentinel values that will be parsed as <code>missing</code>; by default, only an empty field (two consecutive delimiters) is considered <code>missing</code></li><li><code>delim=&#39;,&#39;</code>: a <code>Char</code> or <code>String</code> that indicates how columns are delimited in a file; if no argument is provided, parsing will try to detect the most consistent delimiter on the first 10 rows of the file</li><li><code>ignorerepeated::Bool=false</code>: whether repeated (consecutive) delimiters should be ignored while parsing; useful for fixed-width files with delimiter padding between cells</li><li><code>quotechar=&#39;&quot;&#39;</code>, <code>openquotechar</code>, <code>closequotechar</code>: a <code>Char</code> (or different start and end characters) that indicate a quoted field which may contain textual delimiters or newline characters</li><li><code>escapechar=&#39;&quot;&#39;</code>: the <code>Char</code> used to escape quote characters in a quoted field</li><li><code>dateformat::Union{String, Dates.DateFormat, Nothing}</code>: a date format string to indicate how Date/DateTime columns are formatted for the entire file</li><li><code>decimal=&#39;.&#39;</code>: a <code>Char</code> indicating how decimals are separated in floats, i.e. <code>3.14</code> used &#39;.&#39;, or <code>3,14</code> uses a comma &#39;,&#39;</li><li><code>truestrings</code>, <code>falsestrings</code>: <code>Vectors of Strings</code> that indicate how <code>true</code> or <code>false</code> values are represented; by default only <code>true</code> and <code>false</code> are treated as <code>Bool</code></li></ul></li><li>Column Type Options:<ul><li><code>type</code>: a single type to use for parsing an entire file; i.e. all columns will be treated as the same type; useful for matrix-like data files</li><li><code>types</code>: a Vector or Dict of types to be used for column types; a Dict can map column index <code>Int</code>, or name <code>Symbol</code> or <code>String</code> to type for a column, i.e. Dict(1=&gt;Float64) will set the first column as a Float64, Dict(:column1=&gt;Float64) will set the column named column1 to Float64 and, Dict(&quot;column1&quot;=&gt;Float64) will set the column1 to Float64; if a <code>Vector</code> if provided, it must match the # of columns provided or detected in <code>header</code></li><li><code>typemap::Dict{Type, Type}</code>: a mapping of a type that should be replaced in every instance with another type, i.e. <code>Dict(Float64=&gt;String)</code> would change every detected <code>Float64</code> column to be parsed as <code>String</code></li><li><code>pool::Union{Bool, Float64}=0.1</code>: if <code>true</code>, columns detected as <code>String</code> will be internally pooled; alternatively, the proportion of unique values below which <code>String</code> columns should be pooled (by default 0.1, meaning that if the # of unique strings in a column is under 10%, it will be pooled)</li><li><code>strict::Bool=false</code>: whether invalid values should throw a parsing error or be replaced with <code>missing</code></li><li><code>silencewarnings::Bool=false</code>: if <code>strict=false</code>, whether invalid value warnings should be silenced</li><li><code>copycols::Bool=false</code>: whether a copy of columns should be made when creating the DataFrame; by default, no copy is made, and the DataFrame is built with immutable, read-only CSV.Column vectors. If mutable operations are needed on the DataFrame, set <code>copycols=true</code>.</li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/a7569c0d8cf26a90cb89dbdfe32e2911979577ed/src/CSV.jl#L542-L579">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>CSV.validate</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CSV.write" href="#CSV.write"><code>CSV.write</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">CSV.write(file, file; kwargs...) =&gt; file
table |&gt; CSV.write(file; kwargs...) =&gt; file</code></pre><p>Write a <a href="https://github.com/JuliaData/Tables.jl">Tables.jl interface input</a> to a csv file, given as an <code>IO</code> argument or String/FilePaths.jl type representing the file name to write to.</p><p>Keyword arguments include:</p><ul><li><code>delim::Union{Char, String}=&#39;,&#39;</code>: a character or string to print out as the file&#39;s delimiter</li><li><code>quotechar::Char=&#39;&quot;&#39;</code>: ascii character to use for quoting text fields that may contain delimiters or newlines</li><li><code>openquotechar::Char</code>: instead of <code>quotechar</code>, use <code>openquotechar</code> and <code>closequotechar</code> to support different starting and ending quote characters</li><li><code>escapechar::Char=&#39;&quot;&#39;</code>: ascii character used to escape quote characters in a text field</li><li><code>missingstring::String=&quot;&quot;</code>: string to print </li><li><code>dateformat=Dates.default_format(T)</code>: the date format string to use for printing out Date &amp; DateTime columns</li><li><code>append=false</code>: whether to append writing to an existing file/IO, if <code>true</code>, it will not write column names by default</li><li><code>writeheader=!append</code>: whether to write an initial row of delimited column names, not written by default if appending</li><li><code>header</code>: pass a list of column names (Symbols or Strings) to use instead of the column names of the input table</li><li>`newline=&#39;</li></ul><p>&#39;`: character or string to use to separate rows (lines in the csv file)</p><ul><li><code>quotestrings=false</code>: whether to force all strings to be quoted or not</li><li><code>decimal=&#39;.&#39;</code>: character to use as the decimal point when writing floating point numbers</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/CSV.jl/blob/a7569c0d8cf26a90cb89dbdfe32e2911979577ed/src/write.jl#L1-L21">source</a></section><footer><hr/></footer></article></body></html>
